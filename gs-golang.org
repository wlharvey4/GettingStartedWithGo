#+TEXINFO_FILENAME: gs-golang.info
#+TEXINFO_CLASS: info
#+TEXINFO_HEADER:
#+TEXINFO_POST_HEADER:
#+SUBTITLE:Version {{{version}}} {{{time(%F %R)}}}
#+SUBAUTHOR:
#+TEXINFO_DIR_CATEGORY: Golang
#+TEXINFO_DIR_TITLE: Getting Started With Go
#+TEXINFO_DIR_DESC: Introduction to the Go language
#+TEXINFO_PRINTED_TITLE:Getting Started With Go
#+MACRO: version 0.5
#+OPTIONS: H:4
#+STARTUP: logdone
#+TITLE: Getting Started With Go
#+AUTHOR: WLHarvey4
#+DATE: 2018-12-06

* Course Info

** Name
Getting Started with Go

** Source
University of California, Irvine

** Instructor
 Ian Harris, Professor, Department of Computer Science

*** Welcome from the Instructor
Welcome  to Getting  Started  with  Go! You’re  joining  thousands of  learners
currently enrolled in the course. I'm excited to have you in the class and look
forward to your contributions to the learning community.

To begin, I recommend  taking a few minutes to explore  the course site. Review
the material we’ll cover each week,  and preview the assignments you’ll need to
complete to  pass the  course. Click  Discussions to see  forums where  you can
discuss the course material with fellow students taking the class.

If you have questions  about course content, please post them  in the forums to
get help from  others in the course community. For  technical problems with the
Coursera platform, visit the [[http://learner.coursera.help/][Learner Help Center]].

Good luck as you get started, and I hope you enjoy the course!

** About the Course
Learn  the  basics  of  Go,  an open  source  programming  language  originally
developed by a team  at Google and enhanced by many  contributors from the open
source  community.  This  course  is designed  for  individuals  with  previous
programming experience using  such languages as C, Python, or  Java, and covers
the fundamental elements of Go.  Topics include data types, protocols, formats,
and writing code that incorporates RFCs and JSON. Most importantly, you’ll have
a  chance to  practice  writing  Go programs  and  receive  feedback from  your
peers.  Upon completing  this course,  you'll be  able to  implement simple  Go
programs, which will prepare you for subsequent study at a more advanced level.

** Level
Intermediata

** Specialization
Course 1 in the @@texinfo:@cite{Programming With Google Go Specialization}@@

** How It Works

*** General

**** How do I pass the course
To earn your Course Certificate, you’ll need to earn a passing grade on each of
the  required assignments—these  can  be quizzes,  peer-graded assignments,  or
programming assignments. Videos, readings, and  practice exercises are there to
help you prepare for the graded assignments.

**** What do start dates and end dates mean
Once  you enroll,  you’ll have  access to  all videos,  readings, quizzes,  and
programming assignments  (if applicable). If  you choose to explore  the course
without purchasing, you  may not be able to access  certain assignments. If you
don’t finish all graded assignments before the end of the course, you can reset
your deadlines. Your progress will be saved and you’ll be able to pick up where
you left off.

**** What are due dates? Is there a penalty for submitting my work after a due date
Within a course, there are suggested due dates to help you manage your schedule
and keep coursework from piling up.  Quizzes and programming assignments can be
submitted  late without  consequence. However,  it is  possible that  you won't
receive a  grade if  you submit  your peer-graded  assignment too  late because
classmates  usually  review assignment  within  three  days of  the  assignment
deadline.

**** Can I re-attempt an assignment
Yes. If  you want to improve  your grade, you  can always try again.  If you’re
re-attempting a peer-graded assignment, re-submit your  work as soon as you can
to make sure  there’s enough time for  your classmates to review  your work. In
some cases you  may need to wait before re-submitting  a programming assignment
or quiz. We encourage you to review course material during this delay.

*** Peer-Graded Assignments
Peer-graded assignments require  you and your classmates to  grade each other’s
work.

**** How do peer graded assignments work
After  you  submit your  work,  you’ll  be  asked  to review  your  classmates’
assignments. To  pass, you’ll need to  earn a passing grade  on your submission
and complete the required number of reviews.

**** How are grades calculated
You and your classmates  will be asked to provide a score for  each part of the
assignment.  Final grades  are calculated  by combining  the median  scores you
received for each section.

**** What kind of feedback should I give
Be respectful,  encouraging, and  honest. Acknowledge  what your  classmate did
well and  offer specific  suggestions on  how they  can improve.  Scores should
reflect the learner’s understanding of  the assignment prompt and points should
not be deducted for difficulties with language or differences in opinion.

**** Is there a penalty for submitting my work late
No, but  it’s important to  submit your work  as close to  the due date  as you
can. Classmates  grade most  of the  assignments within three  days of  the due
date. If  you submit yours  too late,  there may not  be anyone to  review your
work.

**** If I fail an assignment, can I try again
Yes! You can always try again, but you’ll need to resubmit your work as soon as
possible to make sure your classmates have enough time to grade your work.

**** Can I edit my assignment
Yes,  but you’ll  need to  re-submit  your work  and any  grade you’ve  already
received will be deleted.

** Syllabus

*** Introduction to the Course
Learn  the  basics  of  Go,  an open  source  programming  language  originally
developed by a team  at Google and enhanced by many  contributors from the open
source community. This is the first in a series of three courses comprising the
Programming with Google Go specialization.  It is designed for individuals with
previous programming experience using such languages as C, Python, or Java, and
covers the  fundamental elements of  Go. Topics include data  types, protocols,
formats, and  writing code that  incorporates RFCs and JSON.  Most importantly,
you’ll have a chance to practice  writing Go programs and receive feedback from
your peers. Upon completing this course,  you’ll be able to implement simple Go
programs,  which  will prepare  you  for  the  remaining  two courses  in  this
specialization: Functions, Methods, and Interfaces in Go and Concurrency in Go.

**** Contents
- One video :: Welcome to the Course
- Reading :: Go Documentation

*** Module 1 --- Getting Started with Go
This first module  gets you started with Go. You'll  learn about the advantages
of using  Go and begin  exploring the  language's features. Midway  through the
module,  you’ll take  a  break from  "theory" and  install  the Go  programming
environment on your computer.  At the end of the module,  you'll write a simple
program that displays “Hello, World” on your screen.

**** Videos
1. Module 1 Overview
2. Why Should I Learn Go? (Advantages of Go)
3. Objects
4. Concurrency
5. Installing Go
6. Workspaces and Packages
7. Go Tool
8. Variables
9. Variable Initialization

**** Activity
- ``Hello, world''

**** Quiz
- Module 1 quiz

*** Module 2 --- Basic Data Types
Now that you’ve set up your programming environment and written a test program,
you’re ready to dive  into data types. This module introduces  data types in Go
and gives you practice writing routines that manipulate different kinds of data
objects, including floating-point numbers and strings.

**** Reading
Read This First!

**** Videos
1. Module 2 Overview
2. Pointers
3. Variable Scope
4. Deallocating Memory
5. Garbage Collection
6. Comments, Printing, Integers
7. Ints, Floats, Strings
8. String Packages
9. Constants
10. Control Flow
11. Control Flow, Scan

**** Activities
- @@texinfo:@file{trunc.go}@@
- @@texinfo:@file{findian.go}@@

**** Quiz
Module 2 quiz

*** Module 3 --- Composite Data Types
At this  point, we’re  ready to  move into more  complex data  types, including
arrays, slices,  maps, and structs.  As in the  previous module, you’ll  have a
chance to practice writing code that makes use of these data types.

**** Videos
1. Module 3 Overview
2. Arrays
3. Slices
4. Variable Slices
5. Hash Tables
6. Maps
7. Structs

**** Activity
- @@texinfo:@file{slice.go}@@

**** Quiz
- Module 3 Quiz

*** Module 4 --- Protocols and Formats
This final  module of the  course introduces the  use of remote  function calls
(RFCs) and JavaScript Object Notation (JSON)  in Go. You’ll learn how to access
and  manipulate data  from external  files, and  have an  opportunity to  write
several routines using Go that exercise this functionality.

**** Videos
1. Module 4 Overview
2. RFCs
3. JSON
4. File Access, ~ioutil~
5. File Acces, ~os~

**** Activities
- @@texinfo:@file{makejson.go}@@
- @@texinfo:@file{read.go}@@

* Introductions

** To the Specialization

*** Welcome to the Programming with Google Go Specialization!
This intermediate-level, three-course sequence  is designed for individuals who
have had some experience programming in  another language but now wish to learn
about the  features and  capabilities of  Go. The courses  provide a  review of
essential  programming concepts,  as needed,  to ensure  that all  learners are
sufficiently comfortable  with the  basics before  learning about  the features
that are peculiar  to Go. (Please note that the  original specialization design
called for four courses but development  of the fourth course has been deferred
to a later  time. For now, please disregard the  occasional references that the
instructor makes to this fourth course.)

The first course, Getting Started with Go, introduces the basic elements of the
language including  unique features such  as slices  that are not  available in
other  programming environments.  The  second course,  Functions, Methods,  and
Interfaces in Go, expands your knowledge  of Go with a focus on object-oriented
features such as classes and encapsulation,  and allows you to practice writing
code to  solve practical problems. The  third and final course,  Concurrency in
Go, shows you how to write Go  code that executes more rapidly through parallel
execution in multi-processor environments.

The courses feature video lectures by  Professor Ian Harris from the University
of   California,   Irvine  and   are   accompanied   by  automatically   graded
multiple-choice quizzes  and peer-reviewed programming assignments.  While most
of the information needed to  complete the programming assignments is presented
within the context of the courses (i.e. by the lecturer), we encourage students
to  take  advantage  of  the  many resources  that  are  available  online  for
clarification and further learning.

** To the Course

*** Introduction to the Course
Learn  the  basics  of  Go,  an open  source  programming  language  originally
developed by a team  at Google and enhanced by many  contributors from the open
source community. This is the first in a series of three courses comprising the
Programming with Google Go specialization.  It is designed for individuals with
previous programming experience using such languages as C, Python, or Java, and
covers the  fundamental elements of  Go. Topics include data  types, protocols,
formats, and  writing code that  incorporates RFCs and JSON.  Most importantly,
you’ll have a chance to practice  writing Go programs and receive feedback from
your peers. Upon completing this course,  you’ll be able to implement simple Go
programs,  which  will prepare  you  for  the  remaining  two courses  in  this
specialization: Functions, Methods, and Interfaces in Go and Concurrency in Go.

*** Welcome to the Course

#+BEGIN_QUOTE

Welcome to the course, Course One. The point of this course is to give you some
first-tier working knowledge of the Go language and how to use it. I'm assuming
that you  already have some experience  programming in other languages,  so I'm
not talking  from scratch  here. I'm assuming  you already have  seen a  lot of
these  concepts. You  know data  types, you  know things  like this,  but maybe
you're familiar with C or Python or Java or something like that and you want to
move over to Go. Maybe you want to start programming systems devices right. You
want to do  some more low-level stuff but  you don't want to go  straight to C,
let's say, or you've been dealing in C in a long time and you want your life to
be easier  right? Something like that.  In fact, Go on  the whole is a  sort of
sweet spot, where  it's efficient, close to  C, but it's also easy  to use like
say maybe Python or  Java, has a lot of that. So it's  in-between, and so we're
going to just hit  on all the basics in this class,  in this particular course,
and you should  be able to program something  and get a feel for it  and see if
you even like this language at all, and if you can be comfortable with it.

#+END_QUOTE

:CI:
#+CINDEX: documentation, getting started
:END:

*** Getting Started With Go Documentation
Here is some [[https://golang.org/doc/#learning][Go  documentation]] that helps you get started  setting up and using
Go. You  don't have to  read all of  it now, just know  that it exists  and can
serve as a valuable resource.

* Module 1 --- Overview

#+BEGIN_QUOTE

Point of  this first  module is  to talk  about more  fully four  things. First
thing, is  we want to talk  about Go, why it's  good, why is unique.  Right? We
want to motivate you,  to just tell you why do you need  even learn this in the
first place  as compared to existing  languages because there are  many, right?
So,  we'll talk  about that.  Then, we'll  have you  start using  Go. So,  this
specifically  means installing  the  Go environment  and  compiling your  first
program, you need to get through that before you can go on with the rest of the
course. So, we'll walk you through the installation process and show you how to
compile  a program  and  see  if it  works  as a  sanity  check  for the  whole
setup. Then,  will start talking  about the code organization,  the recommended
court organization. So, workspace, how you define your workspace, how it should
be organized, how Go code is organized into packages to allow you to share. So,
big point of Go is sharing with other people. Right? Because if you think about
any  real software  you write,  it's  always big.  Right? You  work with  other
people's. Almost never just  you alone. So, you got to  share and packages help
to make  that easy and  to organize the  code so you  can trade your  code with
other  people. Then,  at the  end  of this  module, we'll  start talking  about
variables. Start talk  about the language itself, so the  variables, what types
there are,  and how do  you do scoping, how  variable scoping happens,  how you
basically resolve  the value  of a  variable depending on  where it  occurs and
where it's defined.

#+END_QUOTE

** Advantages of Go
1. Code runs fast
2. Garbage collection
3. Simpler objects

** Objects

#+BEGIN_QUOTE

So, Go language is object-oriented,  but let's say, weakly object-oriented.  it
implements objects  but maybe they  have fewer features  than you would  see in
another object-oriented language  like Python or Java or C++  or something like
that.  Now, I should note right now,  Go does not use this term class.  instead
they use  structs.  Now  structs, actually,  this goes back  to C  and probably
before that.  But  the idea of a struct  is a struct is just the  data. So, the
different types of data that you want to associate together.  So, just the data
are related  together. But  also you  can associate  methods or  functions with
those structs. So, the struct ends up being like what you would call a class in
a normal object-oriented language. So, you  got the structs that had some data,
some fields  of data associated  with them plus some  methods that you  want to
define.  Now,  Go's  implementation  of   structs  is  simplified  compared  to
traditional  implementation of  classes. So,  you don't  have inheritance,  you
don't have constructors, and you don't have generics, none of those. Now, this,
one  can argue  it makes  it easier  to  code, also  it makes  it efficient  to
run. So, it typically runs faster. But it can make it easier to code unless you
like  those  features.  Now,  if  you'd like  inheritance,  and  generics,  and
constructors. Then, you can see this is a disadvantage. But Go is different. It
has objects  but is  different than traditional  object-oriented implementation
and a linear object-oriented implementation.

#+END_QUOTE

** Concurrency

A big advantage of Go is its implementation of *concurrency*.  The language has
built-in constructs that make it easy to use concurrency.

Parallelism through increasing cores, which allows the computer to do more
tasks at one time.  Programming in parallel is difficult, however.
*Concurrency* is the management of multiple tasks at the same time.  Concurrent
programming enables parallelism.  The programmer has to decide how to
partition the code.  The program is making decisions that allows things to run
in parallel.

Go has a lot of concurrency primitives built-in to the language and implemented
efficiently.  Each Go routine represents a separate concurrent task (basically
a thread).  *Select* is used to enable synchronization.  *Channels* are used for
concurrent communication between tasks.

*** Video Transcript on Concurrency
#+BEGIN_QUOTE

One of  the big advantages  of Go, is  its implementation of  concurrency.  So,
we'll talk a little  bit right now about concurrency, what it  is, and why it's
useful, and  how Go  implements it,  how there are  built-in constructs  in the
language that  make it easy  to use concurrency.  a  lot of the  motivation for
concurrency comes  from the need for  speed.  Concurrency is the  management of
multiple  tasks  at the  same  time.   So,  concurrent programming  it  enables
parallelism.  asks  can be alive and  communicating the same time,  then if you
have  the resources,  the parallel  resources multiple  cores, multiple  memory
stuff like  this then you  can map them onto  those parallel resources  and get
parallelism. So, you can't  just take a regular piece of code  and say okay I'm
going to run  it on five cores,  that won't work. The programmer  has to decide
how to partition this code. I want this running on one core, this on another, I
want this  data here  this data there  and so on.   So, that's  what concurrent
programming is about.  The program is  making these decisions that allow things
to run in parallel. If parallel if the hardware exists.  But management of task
execution, so  when our test  starts and stops,  how do two  tests communicate,
send data back  and forth, share memory  if they share memory and  how did they
synchronize? So,  there are times  where one task has  to do something  for the
next task  can start.  So, there are  times where two  tasks can't  be executed
completely in  parallel. There has  to be  some sequential behavior.  This test
can't start until this task ends and  so on. So, that's synchronization and you
have  to  be  able  to  manage  that  inside  your  programming  language.  The
programming   basically  have   to   say,  express   inside   the  code   where
synchronization needs to occur and where it doesn't. So, that's what concurrent
programming  is  and  it is  important  if  you  want  to be  able  to  exploit
parallelism when  it exists.  So, concurrency  in Go.  So, basically  the thing
about  Go, is  that Go  has a  lot of  concurrency primitives  built-in to  the
language and  implemented efficiently. So,  Go routines,  each one of  these Go
routines represents a  concurrent tasks, basically a thread.  Channels are used
for concurrent  for communication between  concurrent tasks. Select is  used to
enable synchronization. These  are just the high level basic  keywords that you
can use. But  we'll talk more about  these later on in  the specialization. But
concurrency, having concurrency  built into the language and  have an efficient
implementation  is advantageous  if you're  doing concurrent  programming which
more and  more, especially with  all the cores  that exists in  processes these
days has become more and more important.

#+END_QUOTE

** Installing Go

*** Installation
 [[https://golang.org/][Golang]] ==> [[https://golang.org/dl/][Download Go]] ==> [[https://golang.org/doc/install][Installation Instructions]]

*** Video Transcription

#+BEGIN_QUOTE

We'll talk right now  about how you download and install the  Go tools, just to
get you  started running a  program. Right now,  we'll talk about  the download
process and  then next I'll  go through actually doing  it, showing you  how to
compile your first  program, but right here, just talk  about installing, which
is  fairly straightforward.  So, first  thing  you are  going  to do  is go  to
golang.org, and this is a snippet of the page when you go there. This isn't the
whole page, I had  to fit it on the slide, but this  is what it basically looks
like, at least right now it does, that  can change over time of course. You can
see the gopher,  see that little gopher.  You'll see that gopher  icon over and
over again. Gopher is the mascot of  the Go programming language like Unix, you
got demons. So, Go  you have the gopher, but the main thing  to look at here is
that button  down there that  says Download Go.  So, that's first  thing you're
going to click on. You're going to see Download Go, you click on that. Actually
also look at  this, on the left side,  when you go to the web  page, you'll see
the whole  screen. I've cut it  off here, but on  the left side, you  could see
there's a yellow box  there where you can type in Go code  and click on the Run
button, it'll  compile and  run it. So,  it'll compile it  remotely and  run it
remotely. We're  not going  to use  that, instead we're  going to  download the
compiler,  we're going  to download  Go Download  to your  machine locally  and
you'll be doing it locally, but if you want to just fool around, you could type
in their,  type some  go program  in there,  click run,  and it  would actually
execute it.  So, what we're doing  now is we're  going to click Download  Go to
download the tools. Now,  when you do that, you come to a  page that looks like
this.  Now, again  I'm only showing a  part of the page, there's  more below it
and  to the  right.  Basically,  when  you download  Go, you  can download  the
precompiled versions for  different platforms. They've got  Windows, and Linux,
and Mac OS and  you can also download the source if you  want to, and you could
compile all of the Go from scratch,  it's whole tools chain from scratch if you
wanted to. We will not be doing that. That is pain. We won't be doing that, but
know that you could, it is open source  and all the sources are right there for
download if you want it.  So, I'm going  to be doing this on a Windows machine,
although you could be doing it on a Linux or a Mac OS machine, either way.  So,
go for the feature  downloads, they make it pretty easy.  For Windows, you pick
that MSI  file that they've  got highlighted  right there. Basically,  what you
want is  the newest stable  precompiled version. I  don't see unstable  ones on
here, but I would recommend the stable, but  it's up to you. Anyway, you go for
a new version, click  the featured one and you download the  MSI. Now, once you
get that, remember if you have an antivirus  on your machine, it can pop up and
worry about this and  complain, but just say okay. Then  once you start running
it, it'll start a wizard.  Now, you've seen these installation wizards and this
is sort of a standard installation wizard. Just obey the wizard and click Next,
Next, and it  will ask you where  you want to install the  tool, what directory
you want it in, and so on. The default locations were fine with me, but that of
course is up to you.

#+END_QUOTE

** Workspaces and Packages

:CI:
#+CINDEX: workspace
#+CINDEX: @env{GOPATH}
#+CINDEX: package
#+CINDEX: main package
#+CINDEX: @code{main()} function
:END:
*** Code Organization --- Workspaces and ~GOPATH~
A  *Workspace*  is  basically  a  directory where  your  Go  source  files  and
supporting files  will reside.  Typically  there is a hierarchy  of directories
where the  Go files will reside.   Common organization is good  for sharing.  A
big motivation  behind the Go language  is for people to  work together easily.
It is  nice to  have a standardized  organization of your  files.  It  makes it
easier to share because everyone knows where to look.

@@texinfo:@heading Workspace Hierarchy@@
Inside your workspace you should have three directories:
 + source directory :: contains source code
 + package directory :: contains other packages that your source code needs
 + bin directory :: contains your compiled executables

@@texinfo:@heading @env{GOPATH} Environment Variable@@

You  will  typically have  one  workspace  for  many projects.   The  workspace
directory  is defined  by  the  @@texinfo:@env{GOPATH}@@ environment  variable.
When   using   the  Go   tools,   assume   that   all   code  is   inside   the
@@texinfo:@env{GOPATH}@@ somewhere.

@@texinfo:@heading Packages@@

There is  the other concept  of *packages*.  Your  code will be  organized into
*packages.*  A @@texinfo:@dfn{package}@@  is  a group  of  related source  code
files.  Any  package can be  imported by any other  package.  The main  use for
this is to easily share code between people and projects.  That is, it is for
software reuse.

The first line of  a file names the package.  Other  packages can be *imported*
using  the ~import~  keyword.  For  example,  ~import "fmt"~  would import  the
Format package used in printing via the ~Printf~ statement.

@@texinfo:@subheading Package Main@@

There always  has to  be one  package called ~main~,  which is  where execution
starts.   When you  build and  compile a  project, the  ~main~ package  is made
executable.  Compilation  of non-~main~ packages  are not made  executable.  In
addition, the  ~main~ file must  have a  function called ~main()~.   Again, the
~main~ function is where execution starts.

@@texinfo:@heading Example Program---Hello World!@@

#+NAME: Hello-World
#+BEGIN_SRC go -n :results output :exports both :tangle hello_world.go
package main
import "fmt"
func main() {
  fmt.Printf("Hello, World!\n")
}
#+END_SRC
*** Video Transcript

#+BEGIN_QUOTE

Right now, we're going to talk about  how code is organized in Go. First, we'll
start with a workspace. So there's this idea of a workspace, and it's basically
a directory where your Go stuff will go, so your Go files. Your Go source files
and  other files  will go  in this  workspace directory.  Typically, there's  a
actually a hierarchy of directories within  your workspace where you will store
the different types of  Go files that you're working with.  Now, the reason why
we're doing this, why the Go  language defines this hierarchy of directories is
because common  organization is good for  sharing. So, a big  motivation behind
Go, the Go  language is for people  to work together easily.  So, remember that
when you're  programming, not necessarily in  this class, in this  class you're
working on  learning the language, the  different aspects of the  language, but
when you get  outside and you're working  in a company or  something like this,
it's  never one  person alone,  it's always  a big  group. You're  working with
people all over the place. They have to be able to work with your code, look at
your  code, merge  it with  their code,  link  it to  their code  that sort  of
thing. So, there's  always this sharing going  on. Maybe you want  to upload to
GitHub and  have a communal  group of people working  on code together.  So for
that, it  is nice  to have  a common standardized  organization of  your files,
right?  It  makes  it  easier  to share  because  then  everybody  knows  where
everything is. Tools know where things are and stuff like that. So, inside your
workspace directory,  what is recommended  are these three  subdirectories. The
source  directory, it  contains  the source  files, your  source  code your  Go
code. Package directory contains packages, the other packages that you're going
to link  in that you need,  and then the  bin directory that contains  all your
executables, your compiled  executables. Now, the programmer  typically has one
workspace for many projects. So, I typically use my one workspace directory and
I can  have 20 projects, 20  different Go projects  I'm working on in  the same
workspace  directory. That's  common.  You don't  have to  do  that but  that's
common. So, one thing to remember  about these directory hierarchy is that it's
recommended  but  it's  not  enforced.  So, this  idea  of  having  the  source
subdirectory, the  bin subdirectory, and  the package subdirectory,  that's not
enforced. So, for instance, you can  have an executable in the source directory
if you want. It is not neat and it's harder for people to share, but it's going
to  run.  You  can compile  it  and  put  it  anywhere  you want  and  run  the
executable. So, it's not  enforced is just a recommendation to  make it easy to
share with  other people.  So, the  workspace directory, you  do have  this one
workspace  directory though,  and this  workspace directory  is defined  by the
GOPATH environment variable.  Now, the GOPATH environment  variable depends on,
how  you  set environment  variables  is  going  to  depend on  your  operating
system.  Normally,  what  happens  is  like on  my  Windows  machine,  but  the
Chaperone, Linux and OS X machine two,  is that the GOPATH directory is set for
you automatically during the installation process. So, that wizard, the install
wizard,  it should  define the  GOPATH  environment variable.  Certainly, on  a
Windows machine, the default directory where it  sticks it, where it puts it is
C:\Users\yourname. So,  for me,  \user\Ian\go. It sets  that as  your workspace
directory.  Now, I  noticed  that  when I  installed  everything,  that was  my
GOPATH. What you see up there \Users\Ian\go. But it actually didn't create a Go
directory. So,  there was  \Users\Ian. I  had to  create the  directory myself,
which is fine. But I had to make  that directory and put my stuff in there. But
understand that that's  the default workspace. You can change  that and you can
go to your GOPATH environment variable  and change your environment variable in
your operating system if you want to,  but for now I'm just assuming that we're
using the  default Gopath.  So, with  Go tools,  I'll assume  that the  code is
inside the GOPATH somewhere. Now, there is this other concept of packages. Your
code is organized  into packages. A package  is a group of  related source code
files. Each package can be imported by  other packages. So, this is the use for
this. The  main use for  this is when you're  working with other  people, other
groups of people in other places, you  write all your code in one package, they
write all  their code in  another package,  and then if  you need to  use their
code, you can use  their code, you can import their package.  So, it's good for
software reuse  that's the  main goal.  The first  line of  the file  names the
package. So, what I'm  showing here in the picture, you can  see these two pink
boxes up  here. These are  two packages  that are defined  and you can  see the
first  line  of, so  those  are  two  different  files, different  source  code
files.  You  can  see  the  package  names  are  listed  at  the  top,  package
package. There's  a bunch  of code  in there and  they're associated  with that
package name.  Then in blue,  I have  some other piece  of code in  a different
source file and it  needs to use the packages from the other  two people. So, I
have an input statement at the top of my blue file and I give the package names
that I want to import.  So, I can use these other two packages  in my code if I
want  to. So,  this is  how packages  get connected  to each  other. It's  very
convenient if you're working with somebody  remotely or somewhere else that you
can clean  separation of  the code.  Now, there  always has  to be  one package
called  main, and  that's where  execution starts.  So, there's  got to  be one
package called main and  you'll note that in the code that  we're working on in
this course, we just have one package  and it is called main. Because we're not
making such big code, we have  different groups of people working together with
different packages right  now. We're just writing one package  called main. But
there must be one package called main  and when you build the main package when
you  compile it,  it makes  an executable  one. So,  note that  when you  build
another package  on the non main  packages, then it doesn't  make it executable
for those, or  not a running executable  because it's not going  to be executed
directly.  It will  be  incorporated  into some  other  package.  But the  main
package, that's  what's going  to be run,  so when you  compile that,  when you
build it, build\compile you get an  executable file. So, the main package needs
to have a  function called main. Main  is where code execution  starts. So, you
can see the example  code right here. It's just printing,  "Hello world". If we
say package  main, import  format, so  that import right  there is  importing a
package. Format it's not a package that  I wrote. Format is one of the packages
that comes  with the Go tool.  So, when you download  the Go tools you  get all
these  standard packages  including format.  The format  package has  a lot  of
functions in it. We'll talk more about  it later. But one of the functions that
it has this print statement, so Printf is included in the format package, so we
have to import that package, and then we make our function main and in there it
just says fmt.Printf hello world. So, pretty straightforward.

#+END_QUOTE

** Go Tool

*** Import
~import~ is a keyword  which is used to access other  packages.  At this point,
these  packages will  be  prebuilt  packages that  come  with  Go.  These  will
implement different functions that are  useful to programmers, for example, the
package  ~fmt~, which  contains the  ~Printf()~  function.  When  a package  is
imported,  the  Go tool  finds  that  package  by  looking in  the  directories
specified   by   the  @@texinfo:@env{GOROOT}@@   and   @@texinfo:@env{GOPATH}@@
environment variables.

@@texinfo:@heading The Go Tool@@

The Go  Tool is  a general tool  used to  manage Go source  code.  It  has many
commands available to it.  A main one is ~build~, i.e., ~go build <arguments>~.
This command  is used to  compile some Go source  code.  It can  have different
arguments, or  no arguments at all,  depending on what you  want to accomplish.
It will create an executable from the ~main~ package.

Another command is ~doc~, which prints documentation for a package.  Another is
~format~, which  will format source  code files.   Another is ~get~  which will
download  non-standard  packages.  ~list~  will  list  the installed  packages.
~run~ compiles a go file, then runs the executable.  ~test~ runs tests.

*** Video Transcription

#+BEGIN_QUOTE

So, we're  going to talk about  the Go Tool a  little bit, just overview  of it
really. It has a  lot of features, and we'll get to  those in different courses
actually during  the specialization. We'll talk  about a little bit  of it now,
but  start off  with import.  So,  just to  restate  what import  does. It's  a
keyword, and it's  used to access other  packages. Now, for the  most part, the
packages that  we're going to be  importing will be the  built-in packages, the
ones that  come with  the Go  language, to  implement different  functions that
we're going to  use in the course.  So, for instance, right now,  right off the
start,  we are  going to  use this  format package,  fmt, and  it has  a printf
statement built into it,  and we use it for printing  things. Now, what happens
is when you do an import, the Go Tool  when it does a build, it has to find the
imported  packages. So,  it searches  through  the directory  specified by  the
GOROOT and the GOPATH environment variables.  So, if you keep everything inside
the GOPATH and the  GOROOT, so inside your work space, it'll  find them. If you
decide you  want to import  some package from some  other place and  maybe it's
installed in a  different directory, something like that, then  you're going to
have to change your  GOPATH and GOROOT paths. You're going  to have to increase
them, change  the path, change the  environment variables, so that  it can find
them. But, that  won't be a problem  for based of the majority  of this course,
we're not doing  that. But I'm saying  in the future, when  you're working with
really big code,  you might need to alter these  environment variables in order
to be able to find the packages that  you're looking for. So, the Go Tool. When
you download Go, you  get this Go Tool, and it's a general  tool used to manage
Go source code. There are many commands, a bunch of different commands that you
can use the Go Tool to do. The first one is going to be go build. So that, it's
just  compiling  the program.  The  arguments  to go  build,  you  can have  no
arguments, in which case it just compiles a.go file in the local directory. But
you can give it a bunch of packages, a bunch of package names, or a bunch of.go
files that  you want to build.  You can give that  as the arguments to  this go
build command. It'll go build whatever you  tell it to build, or you could just
say go build.  Actually, that's what I did  in the demo. I just  said go build,
and I was already in the directory where  I had my main package, and so it just
compiled  that. So,  it creates  an executable  for the  main package,  and the
executable has  the same name  as the first.go file.  So, if you're  just using
one.go file, you're just going to get  that as the name. The.exe suffix is what
you're going to see for executables in Windows in general. So, you'll expect to
see a.exe, and it's  executable, and that should be in  the directory where you
did the build.  If you give it no  other arguments, it'll just place  it in the
same directory. Now, there are tons of arguments to these commands, and I'm not
really going to go through, but you can have arguments where you can tell it to
build and put the executable in a  different directory and so on. I'm not going
to do that right now. We'll finesse that  stuff later. So, some of the other Go
Tool  commands, just  go through  these a  little bit.  Go doc.  Go doc  prints
documentation  for  a  package.  Now,  we'll  go over  this  later,  but  as  a
programmer, you have to put the documentation  in your package, and go doc will
just pull  it out of all  your packages, and  print it. Go format,  that format
source code  files. So, we're not  going to get  heavily into this, but  if you
program at all, you must have heard arguments about, "Oh, you need this type of
indentation and stuff  like this." So, this  go format will just  indent it the
way it should be done. You just give  it the source code file, and it'll indent
it right to  get past all those arguments. There's  a standard indentation. You
don't have to use it. Remember, the indentation isn't forced on you. This isn't
Python or something like that. You don't have  to, but go format will do it for
you, so why not.  Go get downloads packages and installs them.  So, if you want
to get  new packages that  do interesting  things that aren't  standard default
packages, you can say go get and give the name of the package, it'll go online,
find  the  package,  download  it.  Go  list,  list  install  all  the  install
packages. Go run compiles  go file, and it runs the executable.  So if you just
say go build,  that compiles it, and  does not execute it. But  go run actually
compiles it and  then executes the executable  in the end. Or,  if it's already
compiled, it will just run the executable.  Now, you don't need go run, like in
my demo, I think I did a go build  to get the executable. I think it was called
hello.exe. Then,  I just typed hello.exe  at the command line,  and it executed
it. So  I didn't  have to use  go run in  order to  run the executable  but you
can. Go  test, actually the last  course, the fourth in  this specialization is
actually about testing, and we'll get to  that then. Go test, it runs tests. It
looks stuff,  basically, you  have a  bunch of  test files  that end  with this
underscore test.go, and you can run these  tests using the go test command. But
we'll cover that later.

#+END_QUOTE

** Variables

*** Identifiers and Variable Declarations
:CI:
#+CINDEX: variables
#+CINDEX: identifiers
#+CINDEX: declarations
#+CINDEX: variable declarations
:END:
Rules for identifiers is standard.

All variables have to be declared  using the ~var~ keyward, which specifies the
variable's *name* and *type*.  You can optionally declare multiple variables of
the same type on one line.
  : var x int
  : var x, y int

**** Video Transcription

 #+BEGIN_QUOTE

 So now we're  going to start talking  a little bit about the  Go language, will
 broached the  topic of variables  and talk a  little bit about  those variables
 that are  in every  high level language  and we'll just  see how  Go implements
 it. A lot of this is very similar  to what you've seen in other languages, some
 things are  a little bit  different. So first  there's naming. Every-  you need
 names. Names are variables for functions, you  need names to refer to things in
 your code. So names for variables and things like that, they need to start with
 a letter. They can have any number  of letters and digits and underscores, they
 are case sensitive in Go and you can't use keywords. There's a list of keywords
 you  can google  these or  look them  up but  "if", "case",  "package" all  the
 different  keywords,  the language  you  can't  use  those  as the  names.  So,
 variables are basically data stored in memory somewhere. And every variable has
 to  have a  name and  a type.  So  all variables  have to  have a  declaration,
 specifies the name,  and the type of  the variable. So, here's  a really simple
 variable  declaration. Just  as var,  x, int.  So  var is  the key  word for  a
 declaration of a variable.  After that I have the name. So  my name variable is
 called x and then after that I have  the type, var, x, int. That's it. That's a
 declaration of this variable x since it's an integer. And the compiler needs to
 know what type of variable it is, what  the type is, so it knows how much space
 to allocate,  what operations to  perform that type  of thing. You  can declare
 many on the same line if you want to, just comma-separated. So var x, y int and
 you can do that as much as you  want. So variables have types. Type defines the
 values that  a variable can  take and the operations  that can be  performed on
 that variable.  So for  instance common types,  basic types,  integer, floating
 point, strings.  Integers, the  data, the  values that they  can take  are only
 integral values right? They are integers and the operations you can perform are
 integer arithmetic, plus, minus,  times that sort of thing and  there are a set
 of other ones we'll talk about them a little more detail. Floating point, those
 are the data  that they can have,  the values they can have  or fractional like
 decimal  values   and  there   you  have  a   set  of   operations,  arithmetic
 operations.  Actually  they   look  superficially  the  same   as  the  integer
 operations,  plus, times,  divide but  they  may actually  be implemented  with
 different hardware right? Because floating  point division say is significantly
 more  complicated  than integer  division.  So  there's oftentimes  as  special
 hardware just for floating point divide things like this. We don't have to know
 that as  programmers but  the machine  has to  know which  operation to  map it
 to. Then strings. So strings they're a sequence of bytes represented in unicode
 and we'll get into that later. But it's a sequence of bytes, that's the type of
 data the  values it  can take  on and then  the operations  you can  perform on
 strings.  There   are  many   of  them.   String  comparison,   string  search,
 concatenation,  all  sorts  operations  that  you can  you  can  perform  on  a
 string. But  the point is  the type specifies  these things. It  specifies what
 data the variable can hold and how big that data can be right? Because you need
 to know how much space in memory you're going to need to allocate for this. The
 compiler needs to know that and also  what operations are going to be performed
 on it. So what  that's for is eventually the compiler is going  to have to take
 these these operations that you type and  go and compile them into machine code
 instructions  for whatever  the hardware  platform is,  and those  machine code
 instructions can  be different depending on  the type. So for  instance you can
 easily have an add  for an integer, an integer add  up machine code instruction
 which is different  than a floating point add right?  Integer division which is
 different than floating point  division and so on. So this  is why the compiler
 needs to know the type so it knows how to do the compilation, how to convert it
 into machine code.

 #+END_QUOTE

*** Variable Initialization
:CI:
#+CINDEX: initialization
#+CINDEX: variable initialization
#+CINDEX: short variable declaration
:END:
Every variable must be *initialized* prior to using it for the first time.  One
way  to  initialize a  variable  is  to give  it  a  value in  the  declaration
statement.  In such a  case, the type can usually be omitted,  in which case it
is inferred from  the type of the  value.  If a variable is  not initialized in
the  declaration, then  it needs  to be  assigned a  value before  it is  used,
otherwise it is given the ~zero~ value for its type.
  : var x int = 100
  : var x = 100
  : x = 200

There  is   a  third  way  to   initialize  a  variable,  which   is  called  a
@@texinfo:@dfn{short  variable  declaration}@@.   This  only  works  inside  a
function, however.
  : x := 100

**** Video Transcription

#+BEGIN_QUOTE

So  we're  talking about  variables  and  we're going  to  talk  about how  you
initialize them, but first, let's finish up the types. So every variable has to
have a type.

0:20

And  you can  make type  declarations where  you actually  define an  alias, an
alternate name  for a type.  So sometimes this is  useful for clarity  inside a
particular application. For  instance here, it could help you,  say you got you
got some kind of application and it's working on temperatures. Temperatures are
something that it's  manipulating, right? And every temperature you  want it to
be a floating point value, 64 bit floating point value. So you can define a new
type, an alias for  a new type, type Celsius float64. In  that case, Celsius is
exactly the same as float 64. Now,  you can always declare your variables to be
float64, but Celsius might make sense in the context of the application, right?
Maybe the  application is about  temperatures. So maybe  you want to  rename is
[COUGH] just to  make it clearer for  you as a programmer. Also,  like the next
one,  type  IDnum int.  Maybe  I  want to,  maybe  I'm  making some  code  that
implements  a  database  of users  or  something.  And  every  user has  an  ID
number. So I know  this type, this concept ID number. I'd like  to, I know it's
an integer, but I want to name it. I want to give it that name IDnum, so that I
know every variable that it declares an IDnum, it is an IDnum. I know something
about it just  based on the name of  the type. So once you declare  a type like
this, type  Celsius float64 or  type IDnum int,  you can now  declare variables
using that alias. So  I can say var temp Celsius, right? And  now temp is going
to be float64 because  float64 is aliased by Celsius. Also,  var pid IDnum, pid
is actually an integer. But we call it an IDnum and it makes things more clear.

2:04

So initializing variable  values, every variable has to  be initialized somehow
before you use it.

2:11

One way to initialize it is in the declaration itself. So you can say var x int
= 100.  And that will make  x an integer, it'll  declare it as an  integer, but
it'll also set  it equal 100. Or you can  just say var x = 100.  Now, if you do
that you're not saying you want it as an integer. So it will infer the type, it
compile with a further type based on the  type of the right hand side value. So
the number  100 is an  integer, so it  says x must be  an integer, makes  it an
integer. Now,  remember, sometimes  this is  an issue  because maybe  it infers
something you don't want,  right? I like to specify myself,  but maybe. So, for
instance, say I  say x = 100,  but I really want  it to be a  floating point. I
mean,  100.something, right?  But  I  call it  100  because  that's my  initial
temperature that I want, but I want it to be a floating point value. This will,
if I don't specify, it'll say, well, 100 could be an integer, it'll infer it as
an integer. And then if I try to set x to 100.1, I'll have a problem.

3:10

So I like to specify the type, but you don't have to.

3:16

Next up, initializing after the declaration. So you can just say var x int, and
then afterwards you could  say x = 100. And then it'll  follow the line. That's
another way.  Now, if you don't  explicitly initialize a variable,  it'll still
get a value. It'll get the zero value for its type. So, for instance, say I say
var x  int. The 0 value  for its type is  0, right? So x  will be automatically
assigned to a 0, initialized to a 0, if I don't say anything else. If I say var
x string, the zero  value for a string is just the empty  string. So x would be
initialized to the empty string in that case.

3:54

Now, another way to initialize variables is using a short variable declaration.

3:59

Now, in  this case,  you're performing the  declaration and  the initialization
together using the  colon equals operator. So  up on the slide x  := 100, okay?
When you say that, this is a case  where x has not been declared yet, right? So
this statement  actually declares x  and initializes it. Now,  the declaration,
what happens is that when you use that colon equal, the type that it sets it to
be is whatever's on the right hand side. So 100 in this case. It sets, it looks
at 100,  says, that's  an int  and it  infers x to  be an  integer and  then it
assigns it to the  value 100. So variable is declared as  a type of expression,
the type  that's on  the right  hand side. So  it does,  this type  of variable
declaration, it  does the declaration and  the assignment together in  one line
with this  special operator.  You can only  do this inside  a function.  So you
can't do a short variable declaration  outside a function, that's not legal. So
just know that.

#+END_QUOTE

** Peer-Graded Assignment --- ``Hello World''

*** Instructions
The goal of  this initial assignment is  to ensure that you have  set up golang
properly, and that you are ready to proceed through the rest of this course.

*** Review Criteria
This assignment  is worth a total  of 10 points.  5 points will be  awarded for
successful compilation.  Another 5  points will be  awarded if  your screenshot
shows execution and it successfully prints "Hello, world!"

*** TODO Submission [3/4]
    :PROPERTIES:
    :ORDERED:  t
    :END:
 - [X] Download and install the Go tools on your machine. [100%]
   - [X] Download
   - [X] Install
 - [X] Write a Go program to print ``Hello, world!'' on the screen.
 - [X] Compile and run the program.
 - [ ] Submit a screenshot of your cmd window showing you compiling and
   executing your code.  The string ``Hello, world!'' should appear on the
   screen when you execute the code.
* Index
:PROPERTIES:
:INDEX: cp
:END:
